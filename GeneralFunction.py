import numpy as npfrom scipy.interpolate import RegularGridInterpolatorimport scipy.iofrom netCDF4 import Datasetfrom scipy.interpolate import interp2dfrom mpl_toolkits.basemap import Basemap# GLOBAL VARIABLESR_0 = 6371  # earth radius in kilometer# MAP INFORMATIONm = Basemap(  projection="merc",  resolution='c',  area_thresh=0.1,  llcrnrlon=-80,  llcrnrlat=35,  urcrnrlon=0,  urcrnrlat=60)class Bathymetry:    def __init__(self, NetCDF_file):        content = Dataset(NetCDF_file, 'r')        if 'elevation' not in content.variables.keys():            raise ValueError('no elevation data in this file')            return        else:            self.elevation = content.variables['elevation']            self.longi = content.variables['lon']            self.lati = content.variables['lat']            self.f = interp2d(self.longi, self.lati, self.elevation, kind = 'cubic')        def water_depth(self, point):           # INTERPOLATE WATER DEPTH        return self.f(point[0], point[1])    def is_below_depth(self, start_point, end_point, depth):        # CHECK POINTS BETWEEN TWO POINTS WHETHER THEY ARE BELOW THE DEPTH        dist = greatcircle_inverse(start_point[0], start_point[1], end_point[0], end_point[1])[0]#        if dist <= 5.0:#            div = 2#        else:#            div = int(np.floor(dist / 5)) + 2        x, y = m.gcpoints(start_point[0], start_point[1], end_point[0], end_point[1], 10)        x, y = m(x, y, inverse = True)        point = np.c_[x, y]        D = np.array([self.water_depth(p) for p in point])        return np.all(D < depth)# GEOGRAPHIC FUNCTIONdef greatcircle_inverse(lon1, lat1, lon2, lat2):    phi1 = np.radians(lat1)    phi2 = np.radians(lat2)    lam1 = np.radians(lon1)    lam2 = np.radians(lon2)    delta_phi = np.radians(lat2 - lat1)    delta_lam = np.radians(lon2 - lon1)    a = np.sin(delta_phi / 2) * np.sin(delta_phi / 2) + np.cos(phi1) * np.cos(phi2) * np.sin(delta_lam / 2) * np.sin(delta_lam / 2)    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))    y = np.sin(lam2 - lam1) * np.cos(phi2)    x = np.cos(phi1) * np.sin(phi2) - np.sin(phi1) * np.cos(phi2) * np.cos(lam2 - lam1)    bearing = np.degrees(np.arctan2(y, x))    dist = R_0 * c    return np.array([dist, (bearing + 360) % 360])def greatcircle_point(lon1, lat1, dist, bearing):    phi1 = np.radians(lat1)    lam1 = np.radians(lon1)    brng = np.radians(bearing)    dR = dist/R_0    phi2 = np.arcsin(np.sin(phi1) * np.cos(dR) + np.cos(phi1) * np.sin(dR) * np.cos(brng))    lam2 = lam1 + np.arctan2(np.sin(brng) * np.sin(dR) * np.cos(phi1), np.cos(dR) - np.sin(phi1) * np.sin(phi2))    lon2 = np.degrees(lam2)    lat2 = np.degrees(phi2)    y = np.sin(lam1 - lam2) * np.cos(phi1)    x = np.cos(phi2) * np.sin(phi1) - np.sin(phi2) * np.cos(phi1) * np.cos(lam1 - lam2)    bearing2 = np.degrees(np.arctan2(y, x))    return np.array([lon2, lat2, (bearing2 + 180) % 360])# WEATHER INFORMATION CLASSclass WeatherInfo:    def __init__(self, filename):        # LOAD FILE        self.Met = scipy.io.loadmat(filename)        # RANGE OF LONGITUDE, LATITUDE AND TIME        longi = self.Met['lon'][0]        # ORINGINAL FORMAT OF LATITUDE IS NOT ASCENDING, HERE CHANGE IT TO ASCENDING ORDER        lati = self.Met['lat'][:,0][::-1]        time = self.Met['Time']        length_time = len(time)        ti = np.linspace(0, (length_time - 1) * 6, length_time)        #        self.lon = longi        self.lat = lati        self.Hs = self.Met['Hs'][::-1]        self.HDG = self.Met['Theta'][::-1]        self.U = self.Met['wind_U'][::-1]        self.V = self.Met['wind_V'][::-1]        self.TP = self.Met['Tp'][::-1]        self.Hs[self.Hs > 1000] = 0        self.HDG[self.HDG > 1000] = 0        self.TP[self.TP > 1000] = 0        self.current_U = self.U * 0.03        self.current_V = self.V * 0.03        self.current_U[self.current_U > 0.3] = 0.3        self.current_U[self.current_U < -0.3] = -0.3        self.current_V[self.current_V > 0.1] = 0.1        self.current_V[self.current_V < -0.1] = -0.1        #  INTERPOLATE FORMAT CHANGE TO [LATI, LONGI, TIME]        self.hs = RegularGridInterpolator((lati, longi, ti), self.Hs)        self.hdg = RegularGridInterpolator((lati,longi, ti), self.HDG)        self.u = RegularGridInterpolator((lati, longi,ti), self.U)        self.v = RegularGridInterpolator((lati, longi, ti), self.V)        self.tp = RegularGridInterpolator((lati, longi, ti), self.TP)        self.cu = RegularGridInterpolator((lati, longi, ti), self.current_U)        self.cv = RegularGridInterpolator((lati, longi,ti), self.current_V)